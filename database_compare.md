## 事务处理
1. ACID 
原子：要么执行，要么不执行  
一致：事务完成所有数据一致  
隔离：和其他并发事务修改隔离  
持久： 对系统影响是永久的

## 事务模型
- flat
> 一系列原子性的操作组成单个工作单元
- nested
> 事务树 子事务回滚也不会引起外层事务的回滚

## isolation level
1. read uncommitted
> 所有事务可以“看到”未提交事务的执行结果，容易出现脏读，不可重复读，幻读
2. read committed
> 大多数DB默认。它满足了隔离的早先定义：一个事务在开始时，只能“看见”已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的“不可重复读”。这意味着用户运行同一语句两次，看到的结果是不同的
3. repeatable read
> MySql InnoDB 默认。它确保在同一事务的多个实例在并发读取数据时，会“看到同样的”数据行。不过这可能导致幻读，所谓幻读指当用户读取某一范围的数据行时，另一个事务又在修改该范围内插入新行，当用户再读取该范围的数据行时，会发现有新的“幻影”
4. serializable
> 最高级别，强制事务排序，解决幻读

``` 
Isolation并发可能引起如下问题  
第一类：丢失更新 :   
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。 　　 
例:
事务A和事务B同时修改某行的值，
1.事务A将数值改为1并提交
2.事务B将数值改为2并提交。
这时数据的值为2，事务A所做的更新将会丢失。 
解决办法：对行加锁，只允许并发一个更新事务。

第二类：脏读: 

一个事务读到另一个事务未提交的更新数据

例:

1.Mary的原工资为1000, 财务人员将Mary的工资改为了8000(但未提交事务)         
2.Mary读取自己的工资 ,发现自己的工资变为了8000，欢天喜地！
3.而财务发现操作有误，回滚了事务,Mary的工资又变为了1000, 像这样,Mary记取的工资数8000是一个脏数据。

 

第三类：不可重复读: 

在同一个事务中,多次读取同一数据,返回的结果有所不同. 换句话说就是,后续读取可以读到另一个事务已提交的更新数据. 相反"可重复读"在同一事务多次读取数据时,能够保证所读数据一样,也就是后续读取不能读到另一事务已提交的更新数据.

例:

1.在事务1中，Mary 读取了自己的工资为1000,操作并没有完成。
2.在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.  
3.在事务1中，Mary 再次读取自己的工资时，工资变为了2000  
解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。  

 

第四类：幻读: 

一个事务读取到另一个事务已提交的insert数据.

例:

第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时 (此时第一事务还未提交) ，第二个事务向表中插入一行新数据。这时第一个事务再去读取表时,发现表中还有没有修改的数据行，就好象发生了幻觉一样。

 

不可重复读和幻读的区别
很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
```

## 锁
- 悲观锁
> 在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据
- 乐观锁
> 在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

## Memcached
### 优点
- 多核优势，单实例吞吐量极高，几十万QPS（日常4-6w）
- 支持直接配置为session handle

### 缺点
- 支持简单key/value 数据结构
- 无法持久化，数据不能备份，只能用缓存，重启后数据丢失
- 无法数据同步
- 内存分配不均，需重视value大小分布

## Redis

用作数据库或者消息中间件，支持多种类型的数据结构，strings, hashes, lists, sets, sorted sets, bitmaps, hyperlogs, geospatial 地图空间索引半径查询。内置了replication, Lua scripting, LRU eviction, transactions and different level of persistence. 通过哨兵sentinel和自动分区Cluster提供高可用性。

Redis 数据存在内存，定期写入磁盘，内存不够可以指定LRU算法删除数据。  

注意：instance预先分配足够的内存给Redis，如果内存不够需要及时Redis sharding。

### 单点可用
依赖客户端实现分布式读写，主从复制，每次从节点重新连接节点都要依赖整个快照，无增量复制，不支持自动sharding，需要依赖程序设定一致hash机制。  
替代方案：主动复制，多份存储或增量复制。

### 优点
- 支持多种数据结构，string, list, dict, set, zset, hyperloglog
- 支持持久化操作，进行数据备份和恢复（add checkpoint to save data into disk）
- 通过Replication进行数据复制，实时进行数据同步复制，支持多级复制和增量复制
- 单线程请求，所有命令串行执行，并发情况不需要考虑数据一致
- 支持pub/sub 消息订阅机制

### 缺点
- 只支持简单事务需求
- 只能使用单线程，性能受限于CPU性能，单实例5-6w QPS (日常环境QPS 1-2w左右)
- String类型消耗较多的内存，可以使用dict(hash表)压缩存储降低内存耗用。


## MongoDB
数据存在内存，由Linux的mmap实现，内存不够时，只将热点数据放入内存，其他数据存在磁盘。

MongoDB数据存在disk上，保证了可靠性，而且支持sharding，aggregation。按照规定的key进行group by（map）然后进行reduce操作。

支持字段索引，游标操作，查询功能强大，支持JSON数据，存储海量，不支持事务。

### 持久化原理
mysql每次更新写入硬盘。  
MongoDB在启动时，专门初始化一个线程，在一定周期（90ms）从defer队列获取要持久化的数据并写入磁盘的journalhemongofile，因此不会造成性能损耗。记录（Record类型）都被放入defer队列延迟批量提交写入。  
时间周期过低则频繁更新磁盘，过高会造成系统宕机。


### 优点
- 更高的写入负载，插入速度快
- 处理很大规模单表，数据表太大可以很容易分表
- 高可用，M-S
- 快速查询，二维空间索引，从指定位置获取数据，启动后将数据库的数据以文件映射加载到内存
- 非结构化数据爆发增长，弱数据结构模式，添加新字段不会对就表格有影响


### 缺点
- 不支持事务
- 占用空间过大
- 没有成熟维护工具


## 小结
性能：Memcached >= Redis > MongoDB   
便利： Redis 丰富数据操作， MondoDB丰富数据表达，索引，查询  
存储： Memcached LRU算法，Redis 设置过期时间， MongoDB大数据量存储，内存占用很大  
可用： Memcached没有数据冗余，hash或者环状算法解决单点故障；Redis 客户端实现分布式读写；自己实现主动复制；MongoDB支持M_S，auto sharding  
可靠： Memcached用作缓存提升性能，Redis持久化快照，aof增强可靠性但影响性能，MongoDB采用binlog支持持久化  
一致： Memcached 并发场景下，cas保证一致性；Redis 事务支持比较弱；MongoDB不支持事务
数据分析： MongoDB内置数据分析模块（MapReduce）

## 应用场景
Memcached: 缓存提高性能；动态系统提升数据库负载；  
Redis： 数据量较小高性能操作  
MongoDB：海量数据访问效率

## 分析
- 简单的key-value 读，可用memcached；数据持久化，频繁操作，多数据类型，列表做队列，Redis；数据量大：MongoDB  
- Memcached客户端更稳定，Redis协议更复杂  
- Redis持久化到硬盘，缓存性质大于数据存储；MongoDB是存储数据，增删改查比较灵活  
- Redis支持集群，只是M-S模式；MongoDB集群部署
